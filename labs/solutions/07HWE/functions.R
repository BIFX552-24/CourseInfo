# functions.R

library(dplyr)

library(ggplot2)
library(cowplot)
theme_set(theme_cowplot())


###################
# data structures #
###################

#' gens
#' Data on multiple generations of individuals
#' @format A tibble where each row represents a subsequent generation 
#'   including the following fields:
#' @field sim A numeric vector indicating the simulation number
#' @field generation A numeric vector indicating the generation number
#' @field genos A list of genotypes with one vector of genotypes per 
#'   generation. Each value in a vector represents an individual in the 
#'   population, with 0, 1, and 2 representing genotypes AA, AB, and BB
#' @field n A numeric vector indicating the population size.
#' @field p A numeric vector with observed allele frequencies of A.
#' @field q A numeric vector with with observed frequencies of B.
#' @field pAA A numeric vector with observed frequencies of genotype AA.
#' @field pAB A numeric vector with observed frequencies of genotype AB.
#' @field pBB A numeric vector with observed frequencies of genotype BB.


########################
# Simulation functions #
########################

#' @title Simulation functions
#' @name sim_functions
#' @aliases gen0
#' @aliases next_gen
#' @aliases sim_gens
#' 
#' @param genos A vector of genotypes containing previous generations 
#'   (e.g. `gen_prev[[1]]$genos`)
#' @param n Number of individuals to simulate in the next generation
#' @param p Allele frequency of allele A
#' @param nsims Number of populations / simulations to run
#' @param generation Generation number
#' @param sim Simulation number
#' @param mating_fun A function to pair up parents for mating
#' @param state An existing population to build from (i.e. skipping 
#'   the simulation of an initial generation)
#' @return A `gens` object containing simulated population(s).


#' gen0
#' Generate the initial population
#' @rdname sim_functions
#' @details The returned `gens` object only has one row, containing the
#'   initial generation
gen0 <- function(n, p, sim = 1) {
  genos <- sample(0:2, n, 
                  replace = TRUE,
                  prob = c((1-p)^2, 2*p*(1-p), p^2))
  
  # calculate genotype frquencies
  pAA <- sum(genos == 0) / n
  pAB <- sum(genos == 1) / n
  pBB <- sum(genos == 2) / n
  
  # return initial generation
  tibble(genos = list(genos), 
         n = n,
         sim = sim,
         generation = 1,
         p = p,
         q = 1 - p,
         pAA = pAA,
         pAB = pAB,
         pBB = pBB)
}


#' next_gen
#' Generate the next generation
#' @rdname sim_functions
#' @details Individuals in `genos` will be randomly sorted and paired to
#'   generate the next generation. Offspring will be generated by randomly
#'   selecting a pair of parents, generating a single offspring, and 
#'   repeating this process until the desired number of offspring is reached.
next_gen <- function(genos, n, generation, sim = 1, mating_fun = random_mating) {
  
  # pair up parents
  genos <- mating_fun(genos)
  
  # get the most recent generation info (after applying selection)
  n0 <- length(genos)                       # number of individuals in parental
  npairs <- floor(n0/2)                     # number of pairs of parents
  p1 <- 1:npairs * 2 - 1                    # index of second parent in each pair
  p2 <- p1 + 1                              # index of first parent in each pair
  
  # generate offspring
  genos_new <- tibble(parents = sample(1:npairs, n, replace = TRUE), # select a pair of parents for each offspring
                      genos = case_when(genos[p1[parents]] == 0 ~ 0,
                                        genos[p1[parents]] == 1 ~ sample(0:1, n, replace = TRUE),
                                        genos[p1[parents]] == 2 ~ 1) +
                              case_when(genos[p2[parents]] == 0 ~ 0,
                                        genos[p2[parents]] == 1 ~ sample(0:1, n, replace = TRUE),
                                        genos[p2[parents]] == 2 ~ 1))
  
  # return new generation
  tibble(genos = list(genos_new$genos),
         n = n,
         sim = sim,
         generation = generation,
         p = sum(genos_new$genos) / (2*n),
         q = 1 - p,
         pAA = sum(genos_new$genos == 0) / n,
         pAB = sum(genos_new$genos == 1) / n,
         pBB = sum(genos_new$genos == 2) / n)
}


#' sim_gens
#' Simulate multiple generations
#' @rdname sim_functions
#' @description This function simulates multiple generations of a population
#'   and includes the option to start from an existing `gens` object.
sim_gens <- function(n, p, nsims, mating_fun = random_mating,
                     state = NULL) {

  for(i in 1:nsims)
  {
    # simulate the initial population?
    if(is.null(state) | !any(state$sim == i))
    {
      pops <- gen0(n[1], p, i) |>
        
        # and add a row for each subsequent generation
        full_join(tibble(n = n[-1], sim = -1))
      
      # next generation to add
      start_at <- 2
    }else{
      pops <- filter(state, sim == i) |>
        
        # and add a row for each subsequent generation
        full_join(tibble(n = n, sim = -1))

      # pick up where we left off in `state`      
      start_at <- max(pops$generation, na.rm = TRUE) + 1
    }
    
    # simulate subsequent generations
    if(length(n) > 1)
    {
      for(j in start_at:nrow(pops))
      {
        pops[j,] <- next_gen(genos      = pops$genos[[j-1]],
                             n          = pops$n[j],
                             generation = pops$generation[j-1] + 1,
                             sim        = i,
                             mating_fun = mating_fun)
      }
    }
    
    if(i == 1)
    {
      pops_all <- pops
    } else {
      pops_all <- bind_rows(pops_all, pops)
    }
  }
  
  
  return(pops_all)
}


####################
# Mating functions #
####################

#' @name mating_functions
#' 
#' @aliases random_mating
#' @aliases assortative_mating
#' @aliases selection_with_dropout
#'
#' @title Mating functions
#' @param genos A vector of genotypes for individuals to be paired for mating
#' @param dropout The proportion of individuals to keep in the mating pool
#' @param p A vector containing the weights for random selection each
#'   genotype (e.g. 0, 1, 2)
#' @return A vector of genotypes for the paired parents, where the first two
#'   are a pair, second two are a pair, etc.
 
#' random_mating
#' Random mating function
#' @rdname mating_functions
#' @details For random mating, we randomly sort the genotypes.
random_mating <- function(genos)
{
  genos[sample(1:length(genos))]
}

#' assortative_mating
#' Assortative mating function
#' @rdname mating_functions
#' @details For assortative mating, we sort individuals by genotype.
assortative_mating <- function(genos)
{
  genos[order(genos)]
}

#' selection_with_dropout
#' Selection favoring specific genotypes with dropout
#' @rdname mating_functions
#' @details For selection with dropout, we only keep a proportion of the 
#'   individuals, based on the dropout rate. This function is different 
#'   from the other functions in this section in that it returns a function.
selection_with_dropout <- function(dropout, p)
{
  paste("function(genos)",
        "{",
        paste0("p <- ", deparse(p)),
        "genos <- sample(genos,                                            # order by preference with some stochasticity",
        "                size = length(genos),",
        "                prob = p[as.character(genos)])",
        paste0("genos <- genos[1:floor(", dropout ," * length(genos))]     # drop some individuals from the mating pool"),
        "genos[sample(1:length(genos))]                                    # still use random mating",
        "}", sep = "\n") |>
    
    parse(file = "", n = NULL) |>
    eval()
}


###########
# Figures #
###########

#' plot_allele_by_gen
#' Plot the allele frequencies of a `gens` object
#' @param gens A `gens` object
#' @return A ggplot object
plot_allele_by_gen <- function(gens) {
  
  # plot allele frequencies
  gens |>
    ggplot(aes(generation, p)) +
    geom_line(aes(group = sim)) +
    ylab("Allele frequency") +
    lims(y = c(0,1))
}
